{"ast":null,"code":"/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { d as doc } from './index5.js';\nimport { b as getIonMode, c as config } from './ionic-global.js';\nimport { C as CoreDelegate } from './framework-delegate.js';\nimport { OVERLAY_BACK_BUTTON_PRIORITY } from './hardware-back-button.js';\nimport { c as componentOnReady, f as focusElement, a as addEventListener, b as removeEventListener, g as getElementRoot } from './helpers.js';\nimport { p as printIonWarning } from './index6.js';\nlet lastOverlayIndex = 0;\nlet lastId = 0;\nconst activeAnimations = new WeakMap();\nconst createController = tagName => {\n  return {\n    create(options) {\n      return createOverlay(tagName, options);\n    },\n    dismiss(data, role, id) {\n      return dismissOverlay(document, data, role, tagName, id);\n    },\n    async getTop() {\n      return getPresentedOverlay(document, tagName);\n    }\n  };\n};\nconst alertController = /*@__PURE__*/createController('ion-alert');\nconst actionSheetController = /*@__PURE__*/createController('ion-action-sheet');\nconst loadingController = /*@__PURE__*/createController('ion-loading');\nconst modalController = /*@__PURE__*/createController('ion-modal');\nconst pickerController = /*@__PURE__*/createController('ion-picker');\nconst popoverController = /*@__PURE__*/createController('ion-popover');\nconst toastController = /*@__PURE__*/createController('ion-toast');\n/**\n * Prepares the overlay element to be presented.\n */\nconst prepareOverlay = el => {\n  if (typeof document !== 'undefined') {\n    /**\n     * Adds a single instance of event listeners for application behaviors:\n     *\n     * - Escape Key behavior to dismiss an overlay\n     * - Trapping focus within an overlay\n     * - Back button behavior to dismiss an overlay\n     *\n     * This only occurs when the first overlay is created.\n     */\n    connectListeners(document);\n  }\n  const overlayIndex = lastOverlayIndex++;\n  /**\n   * overlayIndex is used in the overlay components to set a zIndex.\n   * This ensures that the most recently presented overlay will be\n   * on top.\n   */\n  el.overlayIndex = overlayIndex;\n};\n/**\n * Assigns an incrementing id to an overlay element, that does not\n * already have an id assigned to it.\n *\n * Used to track unique instances of an overlay element.\n */\nconst setOverlayId = el => {\n  if (!el.hasAttribute('id')) {\n    el.id = `ion-overlay-${++lastId}`;\n  }\n  return el.id;\n};\nconst createOverlay = (tagName, opts) => {\n  // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n  if (typeof window !== 'undefined' && typeof window.customElements !== 'undefined') {\n    return window.customElements.whenDefined(tagName).then(() => {\n      const element = document.createElement(tagName);\n      element.classList.add('overlay-hidden');\n      /**\n       * Convert the passed in overlay options into props\n       * that get passed down into the new overlay.\n       */\n      Object.assign(element, Object.assign(Object.assign({}, opts), {\n        hasController: true\n      }));\n      // append the overlay element to the document body\n      getAppRoot(document).appendChild(element);\n      return new Promise(resolve => componentOnReady(element, resolve));\n    });\n  }\n  return Promise.resolve();\n};\n/**\n * This query string selects elements that\n * are eligible to receive focus. We select\n * interactive elements that meet the following\n * criteria:\n * 1. Element does not have a negative tabindex\n * 2. Element does not have `hidden`\n * 3. Element does not have `disabled` for non-Ionic components.\n * 4. Element does not have `disabled` or `disabled=\"true\"` for Ionic components.\n * Note: We need this distinction because `disabled=\"false\"` is\n * valid usage for the disabled property on ion-button.\n */\nconst focusableQueryString = '[tabindex]:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), input:not([type=hidden]):not([tabindex^=\"-\"]):not([hidden]):not([disabled]), textarea:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), button:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), select:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable[disabled=\"false\"]:not([tabindex^=\"-\"]):not([hidden])';\nconst focusFirstDescendant = (ref, overlay) => {\n  let firstInput = ref.querySelector(focusableQueryString);\n  const shadowRoot = firstInput === null || firstInput === void 0 ? void 0 : firstInput.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    firstInput = shadowRoot.querySelector(focusableQueryString) || firstInput;\n  }\n  if (firstInput) {\n    focusElement(firstInput);\n  } else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\nconst isOverlayHidden = overlay => overlay.classList.contains('overlay-hidden');\nconst focusLastDescendant = (ref, overlay) => {\n  const inputs = Array.from(ref.querySelectorAll(focusableQueryString));\n  let lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;\n  const shadowRoot = lastInput === null || lastInput === void 0 ? void 0 : lastInput.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    lastInput = shadowRoot.querySelector(focusableQueryString) || lastInput;\n  }\n  if (lastInput) {\n    lastInput.focus();\n  } else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\n/**\n * Traps keyboard focus inside of overlay components.\n * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html\n * This includes the following components: Action Sheet, Alert, Loading, Modal,\n * Picker, and Popover.\n * Should NOT include: Toast\n */\nconst trapKeyboardFocus = (ev, doc) => {\n  const lastOverlay = getPresentedOverlay(doc, 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover');\n  const target = ev.target;\n  /**\n   * If no active overlay, ignore this event.\n   *\n   * If this component uses the shadow dom,\n   * this global listener is pointless\n   * since it will not catch the focus\n   * traps as they are inside the shadow root.\n   * We need to add a listener to the shadow root\n   * itself to ensure the focus trap works.\n   */\n  if (!lastOverlay || !target) {\n    return;\n  }\n  /**\n   * If the ion-disable-focus-trap class\n   * is present on an overlay, then this component\n   * instance has opted out of focus trapping.\n   * An example of this is when the sheet modal\n   * has a backdrop that is disabled. The content\n   * behind the sheet should be focusable until\n   * the backdrop is enabled.\n   */\n  if (lastOverlay.classList.contains('ion-disable-focus-trap')) {\n    return;\n  }\n  const trapScopedFocus = () => {\n    /**\n     * If we are focusing the overlay, clear\n     * the last focused element so that hitting\n     * tab activates the first focusable element\n     * in the overlay wrapper.\n     */\n    if (lastOverlay === target) {\n      lastOverlay.lastFocus = undefined;\n      /**\n       * Otherwise, we must be focusing an element\n       * inside of the overlay. The two possible options\n       * here are an input/button/etc or the ion-focus-trap\n       * element. The focus trap element is used to prevent\n       * the keyboard focus from leaving the overlay when\n       * using Tab or screen assistants.\n       */\n    } else {\n      /**\n       * We do not want to focus the traps, so get the overlay\n       * wrapper element as the traps live outside of the wrapper.\n       */\n      const overlayRoot = getElementRoot(lastOverlay);\n      if (!overlayRoot.contains(target)) {\n        return;\n      }\n      const overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');\n      if (!overlayWrapper) {\n        return;\n      }\n      /**\n       * If the target is inside the wrapper, let the browser\n       * focus as normal and keep a log of the last focused element.\n       * Additionally, if the backdrop was tapped we should not\n       * move focus back inside the wrapper as that could cause\n       * an interactive elements focus state to activate.\n       */\n      if (overlayWrapper.contains(target) || target === overlayRoot.querySelector('ion-backdrop')) {\n        lastOverlay.lastFocus = target;\n      } else {\n        /**\n         * Otherwise, we must have focused one of the focus traps.\n         * We need to wrap the focus to either the first element\n         * or the last element.\n         */\n        /**\n         * Once we call `focusFirstDescendant` and focus the first\n         * descendant, another focus event will fire which will\n         * cause `lastOverlay.lastFocus` to be updated before\n         * we can run the code after that. We will cache the value\n         * here to avoid that.\n         */\n        const lastFocus = lastOverlay.lastFocus;\n        // Focus the first element in the overlay wrapper\n        focusFirstDescendant(overlayWrapper, lastOverlay);\n        /**\n         * If the cached last focused element is the\n         * same as the active element, then we need\n         * to wrap focus to the last descendant. This happens\n         * when the first descendant is focused, and the user\n         * presses Shift + Tab. The previous line will focus\n         * the same descendant again (the first one), causing\n         * last focus to equal the active element.\n         */\n        if (lastFocus === doc.activeElement) {\n          focusLastDescendant(overlayWrapper, lastOverlay);\n        }\n        lastOverlay.lastFocus = doc.activeElement;\n      }\n    }\n  };\n  const trapShadowFocus = () => {\n    /**\n     * If the target is inside the wrapper, let the browser\n     * focus as normal and keep a log of the last focused element.\n     */\n    if (lastOverlay.contains(target)) {\n      lastOverlay.lastFocus = target;\n    } else {\n      /**\n       * Otherwise, we are about to have focus\n       * go out of the overlay. We need to wrap\n       * the focus to either the first element\n       * or the last element.\n       */\n      /**\n       * Once we call `focusFirstDescendant` and focus the first\n       * descendant, another focus event will fire which will\n       * cause `lastOverlay.lastFocus` to be updated before\n       * we can run the code after that. We will cache the value\n       * here to avoid that.\n       */\n      const lastFocus = lastOverlay.lastFocus;\n      // Focus the first element in the overlay wrapper\n      focusFirstDescendant(lastOverlay, lastOverlay);\n      /**\n       * If the cached last focused element is the\n       * same as the active element, then we need\n       * to wrap focus to the last descendant. This happens\n       * when the first descendant is focused, and the user\n       * presses Shift + Tab. The previous line will focus\n       * the same descendant again (the first one), causing\n       * last focus to equal the active element.\n       */\n      if (lastFocus === doc.activeElement) {\n        focusLastDescendant(lastOverlay, lastOverlay);\n      }\n      lastOverlay.lastFocus = doc.activeElement;\n    }\n  };\n  if (lastOverlay.shadowRoot) {\n    trapShadowFocus();\n  } else {\n    trapScopedFocus();\n  }\n};\nconst connectListeners = doc => {\n  if (lastOverlayIndex === 0) {\n    lastOverlayIndex = 1;\n    doc.addEventListener('focus', ev => {\n      trapKeyboardFocus(ev, doc);\n    }, true);\n    // handle back-button click\n    doc.addEventListener('ionBackButton', ev => {\n      const lastOverlay = getPresentedOverlay(doc);\n      if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n        ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {\n          return lastOverlay.dismiss(undefined, BACKDROP);\n        });\n      }\n    });\n    // handle ESC to close overlay\n    doc.addEventListener('keydown', ev => {\n      if (ev.key === 'Escape') {\n        const lastOverlay = getPresentedOverlay(doc);\n        if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n          lastOverlay.dismiss(undefined, BACKDROP);\n        }\n      }\n    });\n  }\n};\nconst dismissOverlay = (doc, data, role, overlayTag, id) => {\n  const overlay = getPresentedOverlay(doc, overlayTag, id);\n  if (!overlay) {\n    return Promise.reject('overlay does not exist');\n  }\n  return overlay.dismiss(data, role);\n};\n/**\n * Returns a list of all overlays in the DOM even if they are not presented.\n */\nconst getOverlays = (doc, selector) => {\n  if (selector === undefined) {\n    selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast';\n  }\n  return Array.from(doc.querySelectorAll(selector)).filter(c => c.overlayIndex > 0);\n};\n/**\n * Returns a list of all presented overlays.\n * Inline overlays can exist in the DOM but not be presented,\n * so there are times when we want to exclude those.\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n */\nconst getPresentedOverlays = (doc, overlayTag) => {\n  return getOverlays(doc, overlayTag).filter(o => !isOverlayHidden(o));\n};\n/**\n * Returns a presented overlay element.\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n * @param id The unique identifier for the overlay instance.\n * @returns The overlay element or `undefined` if no overlay element is found.\n */\nconst getPresentedOverlay = (doc, overlayTag, id) => {\n  const overlays = getPresentedOverlays(doc, overlayTag);\n  return id === undefined ? overlays[overlays.length - 1] : overlays.find(o => o.id === id);\n};\n/**\n * When an overlay is presented, the main\n * focus is the overlay not the page content.\n * We need to remove the page content from the\n * accessibility tree otherwise when\n * users use \"read screen from top\" gestures with\n * TalkBack and VoiceOver, the screen reader will begin\n * to read the content underneath the overlay.\n *\n * We need a container where all page components\n * exist that is separate from where the overlays\n * are added in the DOM. For most apps, this element\n * is the top most ion-router-outlet. In the event\n * that devs are not using a router,\n * they will need to add the \"ion-view-container-root\"\n * id to the element that contains all of their views.\n *\n * TODO: If Framework supports having multiple top\n * level router outlets we would need to update this.\n * Example: One outlet for side menu and one outlet\n * for main content.\n */\nconst setRootAriaHidden = (hidden = false) => {\n  const root = getAppRoot(document);\n  const viewContainer = root.querySelector('ion-router-outlet, ion-nav, #ion-view-container-root');\n  if (!viewContainer) {\n    return;\n  }\n  if (hidden) {\n    viewContainer.setAttribute('aria-hidden', 'true');\n  } else {\n    viewContainer.removeAttribute('aria-hidden');\n  }\n};\nconst present = async (overlay, name, iosEnterAnimation, mdEnterAnimation, opts) => {\n  var _a, _b;\n  if (overlay.presented) {\n    return;\n  }\n  setRootAriaHidden(true);\n  overlay.presented = true;\n  overlay.willPresent.emit();\n  (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();\n  const mode = getIonMode(overlay);\n  // get the user's animation fn if one was provided\n  const animationBuilder = overlay.enterAnimation ? overlay.enterAnimation : config.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);\n  const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n  if (completed) {\n    overlay.didPresent.emit();\n    (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();\n  }\n  /**\n   * When an overlay that steals focus\n   * is dismissed, focus should be returned\n   * to the element that was focused\n   * prior to the overlay opening. Toast\n   * does not steal focus and is excluded\n   * from returning focus as a result.\n   */\n  if (overlay.el.tagName !== 'ION-TOAST') {\n    focusPreviousElementOnDismiss(overlay.el);\n  }\n  /**\n   * If the focused element is already\n   * inside the overlay component then\n   * focus should not be moved from that\n   * to the overlay container.\n   */\n  if (overlay.keyboardClose && (document.activeElement === null || !overlay.el.contains(document.activeElement))) {\n    overlay.el.focus();\n  }\n};\n/**\n * When an overlay component is dismissed,\n * focus should be returned to the element\n * that presented the overlay. Otherwise\n * focus will be set on the body which\n * means that people using screen readers\n * or tabbing will need to re-navigate\n * to where they were before they\n * opened the overlay.\n */\nconst focusPreviousElementOnDismiss = async overlayEl => {\n  let previousElement = document.activeElement;\n  if (!previousElement) {\n    return;\n  }\n  const shadowRoot = previousElement === null || previousElement === void 0 ? void 0 : previousElement.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    previousElement = shadowRoot.querySelector(focusableQueryString) || previousElement;\n  }\n  await overlayEl.onDidDismiss();\n  previousElement.focus();\n};\nconst dismiss = async (overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) => {\n  var _a, _b;\n  if (!overlay.presented) {\n    return false;\n  }\n  /**\n   * If this is the last visible overlay then\n   * we want to re-add the root to the accessibility tree.\n   */\n  if (doc !== undefined && getPresentedOverlays(doc).length === 1) {\n    setRootAriaHidden(false);\n  }\n  overlay.presented = false;\n  try {\n    // Overlay contents should not be clickable during dismiss\n    overlay.el.style.setProperty('pointer-events', 'none');\n    overlay.willDismiss.emit({\n      data,\n      role\n    });\n    (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({\n      data,\n      role\n    });\n    const mode = getIonMode(overlay);\n    const animationBuilder = overlay.leaveAnimation ? overlay.leaveAnimation : config.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation);\n    // If dismissed via gesture, no need to play leaving animation again\n    if (role !== GESTURE) {\n      await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n    }\n    overlay.didDismiss.emit({\n      data,\n      role\n    });\n    (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({\n      data,\n      role\n    });\n    activeAnimations.delete(overlay);\n    /**\n     * Make overlay hidden again in case it is being reused.\n     * We can safely remove pointer-events: none as\n     * overlay-hidden will set display: none.\n     */\n    overlay.el.classList.add('overlay-hidden');\n    overlay.el.style.removeProperty('pointer-events');\n    /**\n     * Clear any focus trapping references\n     * when the overlay is dismissed.\n     */\n    if (overlay.el.lastFocus !== undefined) {\n      overlay.el.lastFocus = undefined;\n    }\n  } catch (err) {\n    console.error(err);\n  }\n  overlay.el.remove();\n  return true;\n};\nconst getAppRoot = doc => {\n  return doc.querySelector('ion-app') || doc.body;\n};\nconst overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {\n  // Make overlay visible in case it's hidden\n  baseEl.classList.remove('overlay-hidden');\n  const aniRoot = overlay.el;\n  const animation = animationBuilder(aniRoot, opts);\n  if (!overlay.animated || !config.getBoolean('animated', true)) {\n    animation.duration(0);\n  }\n  if (overlay.keyboardClose) {\n    animation.beforeAddWrite(() => {\n      const activeElement = baseEl.ownerDocument.activeElement;\n      if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.matches('input,ion-input, ion-textarea')) {\n        activeElement.blur();\n      }\n    });\n  }\n  const activeAni = activeAnimations.get(overlay) || [];\n  activeAnimations.set(overlay, [...activeAni, animation]);\n  await animation.play();\n  return true;\n};\nconst eventMethod = (element, eventName) => {\n  let resolve;\n  const promise = new Promise(r => resolve = r);\n  onceEvent(element, eventName, event => {\n    resolve(event.detail);\n  });\n  return promise;\n};\nconst onceEvent = (element, eventName, callback) => {\n  const handler = ev => {\n    removeEventListener(element, eventName, handler);\n    callback(ev);\n  };\n  addEventListener(element, eventName, handler);\n};\nconst isCancel = role => {\n  return role === 'cancel' || role === BACKDROP;\n};\nconst defaultGate = h => h();\n/**\n * Calls a developer provided method while avoiding\n * Angular Zones. Since the handler is provided by\n * the developer, we should throw any errors\n * received so that developer-provided bug\n * tracking software can log it.\n */\nconst safeCall = (handler, arg) => {\n  if (typeof handler === 'function') {\n    const jmp = config.get('_zoneGate', defaultGate);\n    return jmp(() => {\n      try {\n        return handler(arg);\n      } catch (e) {\n        throw e;\n      }\n    });\n  }\n  return undefined;\n};\nconst BACKDROP = 'backdrop';\nconst GESTURE = 'gesture';\nconst OVERLAY_GESTURE_PRIORITY = 39;\n/**\n * Creates a delegate controller.\n *\n * Requires that the component has the following properties:\n * - `el: HTMLElement`\n * - `hasController: boolean`\n * - `delegate?: FrameworkDelegate`\n *\n * @param ref The component class instance.\n */\nconst createDelegateController = ref => {\n  let inline = false;\n  let workingDelegate;\n  const coreDelegate = CoreDelegate();\n  /**\n   * Determines whether or not an overlay is being used\n   * inline or via a controller/JS and returns the correct delegate.\n   * By default, subsequent calls to getDelegate will use\n   * a cached version of the delegate.\n   * This is useful for calling dismiss after present,\n   * so that the correct delegate is given.\n   * @param force `true` to force the non-cached version of the delegate.\n   * @returns The delegate to use and whether or not the overlay is inline.\n   */\n  const getDelegate = (force = false) => {\n    if (workingDelegate && !force) {\n      return {\n        delegate: workingDelegate,\n        inline\n      };\n    }\n    const {\n      el,\n      hasController,\n      delegate\n    } = ref;\n    /**\n     * If using overlay inline\n     * we potentially need to use the coreDelegate\n     * so that this works in vanilla JS apps.\n     * If a developer has presented this component\n     * via a controller, then we can assume\n     * the component is already in the\n     * correct place.\n     */\n    const parentEl = el.parentNode;\n    inline = parentEl !== null && !hasController;\n    workingDelegate = inline ? delegate || coreDelegate : delegate;\n    return {\n      inline,\n      delegate: workingDelegate\n    };\n  };\n  /**\n   * Attaches a component in the DOM. Teleports the component\n   * to the root of the app.\n   * @param component The component to optionally construct and append to the element.\n   */\n  const attachViewToDom = async component => {\n    const {\n      delegate\n    } = getDelegate(true);\n    if (delegate) {\n      return await delegate.attachViewToDom(ref.el, component);\n    }\n    const {\n      hasController\n    } = ref;\n    if (hasController && component !== undefined) {\n      throw new Error('framework delegate is missing');\n    }\n    return null;\n  };\n  /**\n   * Moves a component back to its original location in the DOM.\n   */\n  const removeViewFromDom = () => {\n    const {\n      delegate\n    } = getDelegate();\n    if (delegate && ref.el !== undefined) {\n      delegate.removeViewFromDom(ref.el.parentElement, ref.el);\n    }\n  };\n  return {\n    attachViewToDom,\n    removeViewFromDom\n  };\n};\n/**\n * Constructs a trigger interaction for an overlay.\n * Presents an overlay when the trigger is clicked.\n *\n * Usage:\n * ```ts\n * triggerController = createTriggerController();\n * triggerController.addClickListener(el, trigger);\n * ```\n */\nconst createTriggerController = () => {\n  let destroyTriggerInteraction;\n  /**\n   * Removes the click listener from the trigger element.\n   */\n  const removeClickListener = () => {\n    if (destroyTriggerInteraction) {\n      destroyTriggerInteraction();\n      destroyTriggerInteraction = undefined;\n    }\n  };\n  /**\n   * Adds a click listener to the trigger element.\n   * Presents the overlay when the trigger is clicked.\n   * @param el The overlay element.\n   * @param trigger The ID of the element to add a click listener to.\n   */\n  const addClickListener = (el, trigger) => {\n    removeClickListener();\n    const triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;\n    if (!triggerEl) {\n      printIonWarning(`A trigger element with the ID \"${trigger}\" was not found in the DOM. The trigger element must be in the DOM when the \"trigger\" property is set on an overlay component.`, el);\n      return;\n    }\n    const configureTriggerInteraction = (targetEl, overlayEl) => {\n      const openOverlay = () => {\n        overlayEl.present();\n      };\n      targetEl.addEventListener('click', openOverlay);\n      return () => {\n        targetEl.removeEventListener('click', openOverlay);\n      };\n    };\n    destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el);\n  };\n  return {\n    addClickListener,\n    removeClickListener\n  };\n};\nexport { BACKDROP as B, GESTURE as G, OVERLAY_GESTURE_PRIORITY as O, alertController as a, actionSheetController as b, popoverController as c, createDelegateController as d, createTriggerController as e, present as f, dismiss as g, eventMethod as h, isCancel as i, prepareOverlay as j, setOverlayId as k, loadingController as l, modalController as m, focusFirstDescendant as n, getPresentedOverlay as o, pickerController as p, activeAnimations as q, safeCall as s, toastController as t };","map":{"version":3,"names":["d","doc","b","getIonMode","c","config","C","CoreDelegate","OVERLAY_BACK_BUTTON_PRIORITY","componentOnReady","f","focusElement","a","addEventListener","removeEventListener","g","getElementRoot","p","printIonWarning","lastOverlayIndex","lastId","activeAnimations","WeakMap","createController","tagName","create","options","createOverlay","dismiss","data","role","id","dismissOverlay","document","getTop","getPresentedOverlay","alertController","actionSheetController","loadingController","modalController","pickerController","popoverController","toastController","prepareOverlay","el","connectListeners","overlayIndex","setOverlayId","hasAttribute","opts","window","customElements","whenDefined","then","element","createElement","classList","add","Object","assign","hasController","getAppRoot","appendChild","Promise","resolve","focusableQueryString","focusFirstDescendant","ref","overlay","firstInput","querySelector","shadowRoot","focus","isOverlayHidden","contains","focusLastDescendant","inputs","Array","from","querySelectorAll","lastInput","length","trapKeyboardFocus","ev","lastOverlay","target","trapScopedFocus","lastFocus","undefined","overlayRoot","overlayWrapper","activeElement","trapShadowFocus","backdropDismiss","detail","register","BACKDROP","key","overlayTag","reject","getOverlays","selector","filter","getPresentedOverlays","o","overlays","find","setRootAriaHidden","hidden","root","viewContainer","setAttribute","removeAttribute","present","name","iosEnterAnimation","mdEnterAnimation","_a","_b","presented","willPresent","emit","willPresentShorthand","mode","animationBuilder","enterAnimation","get","completed","overlayAnimation","didPresent","didPresentShorthand","focusPreviousElementOnDismiss","keyboardClose","overlayEl","previousElement","onDidDismiss","iosLeaveAnimation","mdLeaveAnimation","style","setProperty","willDismiss","willDismissShorthand","leaveAnimation","GESTURE","didDismiss","didDismissShorthand","delete","removeProperty","err","console","error","remove","body","baseEl","aniRoot","animation","animated","getBoolean","duration","beforeAddWrite","ownerDocument","matches","blur","activeAni","set","play","eventMethod","eventName","promise","r","onceEvent","event","callback","handler","isCancel","defaultGate","h","safeCall","arg","jmp","e","OVERLAY_GESTURE_PRIORITY","createDelegateController","inline","workingDelegate","coreDelegate","getDelegate","force","delegate","parentEl","parentNode","attachViewToDom","component","Error","removeViewFromDom","parentElement","createTriggerController","destroyTriggerInteraction","removeClickListener","addClickListener","trigger","triggerEl","getElementById","configureTriggerInteraction","targetEl","openOverlay","B","G","O","i","j","k","l","m","n","q","s","t"],"sources":["/Users/trieuvy/Document/hom-nay-an-gi/node_modules/@ionic/core/components/overlays.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { d as doc } from './index5.js';\nimport { b as getIonMode, c as config } from './ionic-global.js';\nimport { C as CoreDelegate } from './framework-delegate.js';\nimport { OVERLAY_BACK_BUTTON_PRIORITY } from './hardware-back-button.js';\nimport { c as componentOnReady, f as focusElement, a as addEventListener, b as removeEventListener, g as getElementRoot } from './helpers.js';\nimport { p as printIonWarning } from './index6.js';\n\nlet lastOverlayIndex = 0;\nlet lastId = 0;\nconst activeAnimations = new WeakMap();\nconst createController = (tagName) => {\n    return {\n        create(options) {\n            return createOverlay(tagName, options);\n        },\n        dismiss(data, role, id) {\n            return dismissOverlay(document, data, role, tagName, id);\n        },\n        async getTop() {\n            return getPresentedOverlay(document, tagName);\n        },\n    };\n};\nconst alertController = /*@__PURE__*/ createController('ion-alert');\nconst actionSheetController = /*@__PURE__*/ createController('ion-action-sheet');\nconst loadingController = /*@__PURE__*/ createController('ion-loading');\nconst modalController = /*@__PURE__*/ createController('ion-modal');\nconst pickerController = /*@__PURE__*/ createController('ion-picker');\nconst popoverController = /*@__PURE__*/ createController('ion-popover');\nconst toastController = /*@__PURE__*/ createController('ion-toast');\n/**\n * Prepares the overlay element to be presented.\n */\nconst prepareOverlay = (el) => {\n    if (typeof document !== 'undefined') {\n        /**\n         * Adds a single instance of event listeners for application behaviors:\n         *\n         * - Escape Key behavior to dismiss an overlay\n         * - Trapping focus within an overlay\n         * - Back button behavior to dismiss an overlay\n         *\n         * This only occurs when the first overlay is created.\n         */\n        connectListeners(document);\n    }\n    const overlayIndex = lastOverlayIndex++;\n    /**\n     * overlayIndex is used in the overlay components to set a zIndex.\n     * This ensures that the most recently presented overlay will be\n     * on top.\n     */\n    el.overlayIndex = overlayIndex;\n};\n/**\n * Assigns an incrementing id to an overlay element, that does not\n * already have an id assigned to it.\n *\n * Used to track unique instances of an overlay element.\n */\nconst setOverlayId = (el) => {\n    if (!el.hasAttribute('id')) {\n        el.id = `ion-overlay-${++lastId}`;\n    }\n    return el.id;\n};\nconst createOverlay = (tagName, opts) => {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof window !== 'undefined' && typeof window.customElements !== 'undefined') {\n        return window.customElements.whenDefined(tagName).then(() => {\n            const element = document.createElement(tagName);\n            element.classList.add('overlay-hidden');\n            /**\n             * Convert the passed in overlay options into props\n             * that get passed down into the new overlay.\n             */\n            Object.assign(element, Object.assign(Object.assign({}, opts), { hasController: true }));\n            // append the overlay element to the document body\n            getAppRoot(document).appendChild(element);\n            return new Promise((resolve) => componentOnReady(element, resolve));\n        });\n    }\n    return Promise.resolve();\n};\n/**\n * This query string selects elements that\n * are eligible to receive focus. We select\n * interactive elements that meet the following\n * criteria:\n * 1. Element does not have a negative tabindex\n * 2. Element does not have `hidden`\n * 3. Element does not have `disabled` for non-Ionic components.\n * 4. Element does not have `disabled` or `disabled=\"true\"` for Ionic components.\n * Note: We need this distinction because `disabled=\"false\"` is\n * valid usage for the disabled property on ion-button.\n */\nconst focusableQueryString = '[tabindex]:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), input:not([type=hidden]):not([tabindex^=\"-\"]):not([hidden]):not([disabled]), textarea:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), button:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), select:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable[disabled=\"false\"]:not([tabindex^=\"-\"]):not([hidden])';\nconst focusFirstDescendant = (ref, overlay) => {\n    let firstInput = ref.querySelector(focusableQueryString);\n    const shadowRoot = firstInput === null || firstInput === void 0 ? void 0 : firstInput.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        firstInput = shadowRoot.querySelector(focusableQueryString) || firstInput;\n    }\n    if (firstInput) {\n        focusElement(firstInput);\n    }\n    else {\n        // Focus overlay instead of letting focus escape\n        overlay.focus();\n    }\n};\nconst isOverlayHidden = (overlay) => overlay.classList.contains('overlay-hidden');\nconst focusLastDescendant = (ref, overlay) => {\n    const inputs = Array.from(ref.querySelectorAll(focusableQueryString));\n    let lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;\n    const shadowRoot = lastInput === null || lastInput === void 0 ? void 0 : lastInput.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        lastInput = shadowRoot.querySelector(focusableQueryString) || lastInput;\n    }\n    if (lastInput) {\n        lastInput.focus();\n    }\n    else {\n        // Focus overlay instead of letting focus escape\n        overlay.focus();\n    }\n};\n/**\n * Traps keyboard focus inside of overlay components.\n * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html\n * This includes the following components: Action Sheet, Alert, Loading, Modal,\n * Picker, and Popover.\n * Should NOT include: Toast\n */\nconst trapKeyboardFocus = (ev, doc) => {\n    const lastOverlay = getPresentedOverlay(doc, 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover');\n    const target = ev.target;\n    /**\n     * If no active overlay, ignore this event.\n     *\n     * If this component uses the shadow dom,\n     * this global listener is pointless\n     * since it will not catch the focus\n     * traps as they are inside the shadow root.\n     * We need to add a listener to the shadow root\n     * itself to ensure the focus trap works.\n     */\n    if (!lastOverlay || !target) {\n        return;\n    }\n    /**\n     * If the ion-disable-focus-trap class\n     * is present on an overlay, then this component\n     * instance has opted out of focus trapping.\n     * An example of this is when the sheet modal\n     * has a backdrop that is disabled. The content\n     * behind the sheet should be focusable until\n     * the backdrop is enabled.\n     */\n    if (lastOverlay.classList.contains('ion-disable-focus-trap')) {\n        return;\n    }\n    const trapScopedFocus = () => {\n        /**\n         * If we are focusing the overlay, clear\n         * the last focused element so that hitting\n         * tab activates the first focusable element\n         * in the overlay wrapper.\n         */\n        if (lastOverlay === target) {\n            lastOverlay.lastFocus = undefined;\n            /**\n             * Otherwise, we must be focusing an element\n             * inside of the overlay. The two possible options\n             * here are an input/button/etc or the ion-focus-trap\n             * element. The focus trap element is used to prevent\n             * the keyboard focus from leaving the overlay when\n             * using Tab or screen assistants.\n             */\n        }\n        else {\n            /**\n             * We do not want to focus the traps, so get the overlay\n             * wrapper element as the traps live outside of the wrapper.\n             */\n            const overlayRoot = getElementRoot(lastOverlay);\n            if (!overlayRoot.contains(target)) {\n                return;\n            }\n            const overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');\n            if (!overlayWrapper) {\n                return;\n            }\n            /**\n             * If the target is inside the wrapper, let the browser\n             * focus as normal and keep a log of the last focused element.\n             * Additionally, if the backdrop was tapped we should not\n             * move focus back inside the wrapper as that could cause\n             * an interactive elements focus state to activate.\n             */\n            if (overlayWrapper.contains(target) || target === overlayRoot.querySelector('ion-backdrop')) {\n                lastOverlay.lastFocus = target;\n            }\n            else {\n                /**\n                 * Otherwise, we must have focused one of the focus traps.\n                 * We need to wrap the focus to either the first element\n                 * or the last element.\n                 */\n                /**\n                 * Once we call `focusFirstDescendant` and focus the first\n                 * descendant, another focus event will fire which will\n                 * cause `lastOverlay.lastFocus` to be updated before\n                 * we can run the code after that. We will cache the value\n                 * here to avoid that.\n                 */\n                const lastFocus = lastOverlay.lastFocus;\n                // Focus the first element in the overlay wrapper\n                focusFirstDescendant(overlayWrapper, lastOverlay);\n                /**\n                 * If the cached last focused element is the\n                 * same as the active element, then we need\n                 * to wrap focus to the last descendant. This happens\n                 * when the first descendant is focused, and the user\n                 * presses Shift + Tab. The previous line will focus\n                 * the same descendant again (the first one), causing\n                 * last focus to equal the active element.\n                 */\n                if (lastFocus === doc.activeElement) {\n                    focusLastDescendant(overlayWrapper, lastOverlay);\n                }\n                lastOverlay.lastFocus = doc.activeElement;\n            }\n        }\n    };\n    const trapShadowFocus = () => {\n        /**\n         * If the target is inside the wrapper, let the browser\n         * focus as normal and keep a log of the last focused element.\n         */\n        if (lastOverlay.contains(target)) {\n            lastOverlay.lastFocus = target;\n        }\n        else {\n            /**\n             * Otherwise, we are about to have focus\n             * go out of the overlay. We need to wrap\n             * the focus to either the first element\n             * or the last element.\n             */\n            /**\n             * Once we call `focusFirstDescendant` and focus the first\n             * descendant, another focus event will fire which will\n             * cause `lastOverlay.lastFocus` to be updated before\n             * we can run the code after that. We will cache the value\n             * here to avoid that.\n             */\n            const lastFocus = lastOverlay.lastFocus;\n            // Focus the first element in the overlay wrapper\n            focusFirstDescendant(lastOverlay, lastOverlay);\n            /**\n             * If the cached last focused element is the\n             * same as the active element, then we need\n             * to wrap focus to the last descendant. This happens\n             * when the first descendant is focused, and the user\n             * presses Shift + Tab. The previous line will focus\n             * the same descendant again (the first one), causing\n             * last focus to equal the active element.\n             */\n            if (lastFocus === doc.activeElement) {\n                focusLastDescendant(lastOverlay, lastOverlay);\n            }\n            lastOverlay.lastFocus = doc.activeElement;\n        }\n    };\n    if (lastOverlay.shadowRoot) {\n        trapShadowFocus();\n    }\n    else {\n        trapScopedFocus();\n    }\n};\nconst connectListeners = (doc) => {\n    if (lastOverlayIndex === 0) {\n        lastOverlayIndex = 1;\n        doc.addEventListener('focus', (ev) => {\n            trapKeyboardFocus(ev, doc);\n        }, true);\n        // handle back-button click\n        doc.addEventListener('ionBackButton', (ev) => {\n            const lastOverlay = getPresentedOverlay(doc);\n            if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n                ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {\n                    return lastOverlay.dismiss(undefined, BACKDROP);\n                });\n            }\n        });\n        // handle ESC to close overlay\n        doc.addEventListener('keydown', (ev) => {\n            if (ev.key === 'Escape') {\n                const lastOverlay = getPresentedOverlay(doc);\n                if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n                    lastOverlay.dismiss(undefined, BACKDROP);\n                }\n            }\n        });\n    }\n};\nconst dismissOverlay = (doc, data, role, overlayTag, id) => {\n    const overlay = getPresentedOverlay(doc, overlayTag, id);\n    if (!overlay) {\n        return Promise.reject('overlay does not exist');\n    }\n    return overlay.dismiss(data, role);\n};\n/**\n * Returns a list of all overlays in the DOM even if they are not presented.\n */\nconst getOverlays = (doc, selector) => {\n    if (selector === undefined) {\n        selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast';\n    }\n    return Array.from(doc.querySelectorAll(selector)).filter((c) => c.overlayIndex > 0);\n};\n/**\n * Returns a list of all presented overlays.\n * Inline overlays can exist in the DOM but not be presented,\n * so there are times when we want to exclude those.\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n */\nconst getPresentedOverlays = (doc, overlayTag) => {\n    return getOverlays(doc, overlayTag).filter((o) => !isOverlayHidden(o));\n};\n/**\n * Returns a presented overlay element.\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n * @param id The unique identifier for the overlay instance.\n * @returns The overlay element or `undefined` if no overlay element is found.\n */\nconst getPresentedOverlay = (doc, overlayTag, id) => {\n    const overlays = getPresentedOverlays(doc, overlayTag);\n    return id === undefined ? overlays[overlays.length - 1] : overlays.find((o) => o.id === id);\n};\n/**\n * When an overlay is presented, the main\n * focus is the overlay not the page content.\n * We need to remove the page content from the\n * accessibility tree otherwise when\n * users use \"read screen from top\" gestures with\n * TalkBack and VoiceOver, the screen reader will begin\n * to read the content underneath the overlay.\n *\n * We need a container where all page components\n * exist that is separate from where the overlays\n * are added in the DOM. For most apps, this element\n * is the top most ion-router-outlet. In the event\n * that devs are not using a router,\n * they will need to add the \"ion-view-container-root\"\n * id to the element that contains all of their views.\n *\n * TODO: If Framework supports having multiple top\n * level router outlets we would need to update this.\n * Example: One outlet for side menu and one outlet\n * for main content.\n */\nconst setRootAriaHidden = (hidden = false) => {\n    const root = getAppRoot(document);\n    const viewContainer = root.querySelector('ion-router-outlet, ion-nav, #ion-view-container-root');\n    if (!viewContainer) {\n        return;\n    }\n    if (hidden) {\n        viewContainer.setAttribute('aria-hidden', 'true');\n    }\n    else {\n        viewContainer.removeAttribute('aria-hidden');\n    }\n};\nconst present = async (overlay, name, iosEnterAnimation, mdEnterAnimation, opts) => {\n    var _a, _b;\n    if (overlay.presented) {\n        return;\n    }\n    setRootAriaHidden(true);\n    overlay.presented = true;\n    overlay.willPresent.emit();\n    (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();\n    const mode = getIonMode(overlay);\n    // get the user's animation fn if one was provided\n    const animationBuilder = overlay.enterAnimation\n        ? overlay.enterAnimation\n        : config.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);\n    const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n    if (completed) {\n        overlay.didPresent.emit();\n        (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();\n    }\n    /**\n     * When an overlay that steals focus\n     * is dismissed, focus should be returned\n     * to the element that was focused\n     * prior to the overlay opening. Toast\n     * does not steal focus and is excluded\n     * from returning focus as a result.\n     */\n    if (overlay.el.tagName !== 'ION-TOAST') {\n        focusPreviousElementOnDismiss(overlay.el);\n    }\n    /**\n     * If the focused element is already\n     * inside the overlay component then\n     * focus should not be moved from that\n     * to the overlay container.\n     */\n    if (overlay.keyboardClose && (document.activeElement === null || !overlay.el.contains(document.activeElement))) {\n        overlay.el.focus();\n    }\n};\n/**\n * When an overlay component is dismissed,\n * focus should be returned to the element\n * that presented the overlay. Otherwise\n * focus will be set on the body which\n * means that people using screen readers\n * or tabbing will need to re-navigate\n * to where they were before they\n * opened the overlay.\n */\nconst focusPreviousElementOnDismiss = async (overlayEl) => {\n    let previousElement = document.activeElement;\n    if (!previousElement) {\n        return;\n    }\n    const shadowRoot = previousElement === null || previousElement === void 0 ? void 0 : previousElement.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        previousElement = shadowRoot.querySelector(focusableQueryString) || previousElement;\n    }\n    await overlayEl.onDidDismiss();\n    previousElement.focus();\n};\nconst dismiss = async (overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) => {\n    var _a, _b;\n    if (!overlay.presented) {\n        return false;\n    }\n    /**\n     * If this is the last visible overlay then\n     * we want to re-add the root to the accessibility tree.\n     */\n    if (doc !== undefined && getPresentedOverlays(doc).length === 1) {\n        setRootAriaHidden(false);\n    }\n    overlay.presented = false;\n    try {\n        // Overlay contents should not be clickable during dismiss\n        overlay.el.style.setProperty('pointer-events', 'none');\n        overlay.willDismiss.emit({ data, role });\n        (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({ data, role });\n        const mode = getIonMode(overlay);\n        const animationBuilder = overlay.leaveAnimation\n            ? overlay.leaveAnimation\n            : config.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation);\n        // If dismissed via gesture, no need to play leaving animation again\n        if (role !== GESTURE) {\n            await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n        }\n        overlay.didDismiss.emit({ data, role });\n        (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({ data, role });\n        activeAnimations.delete(overlay);\n        /**\n         * Make overlay hidden again in case it is being reused.\n         * We can safely remove pointer-events: none as\n         * overlay-hidden will set display: none.\n         */\n        overlay.el.classList.add('overlay-hidden');\n        overlay.el.style.removeProperty('pointer-events');\n        /**\n         * Clear any focus trapping references\n         * when the overlay is dismissed.\n         */\n        if (overlay.el.lastFocus !== undefined) {\n            overlay.el.lastFocus = undefined;\n        }\n    }\n    catch (err) {\n        console.error(err);\n    }\n    overlay.el.remove();\n    return true;\n};\nconst getAppRoot = (doc) => {\n    return doc.querySelector('ion-app') || doc.body;\n};\nconst overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {\n    // Make overlay visible in case it's hidden\n    baseEl.classList.remove('overlay-hidden');\n    const aniRoot = overlay.el;\n    const animation = animationBuilder(aniRoot, opts);\n    if (!overlay.animated || !config.getBoolean('animated', true)) {\n        animation.duration(0);\n    }\n    if (overlay.keyboardClose) {\n        animation.beforeAddWrite(() => {\n            const activeElement = baseEl.ownerDocument.activeElement;\n            if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.matches('input,ion-input, ion-textarea')) {\n                activeElement.blur();\n            }\n        });\n    }\n    const activeAni = activeAnimations.get(overlay) || [];\n    activeAnimations.set(overlay, [...activeAni, animation]);\n    await animation.play();\n    return true;\n};\nconst eventMethod = (element, eventName) => {\n    let resolve;\n    const promise = new Promise((r) => (resolve = r));\n    onceEvent(element, eventName, (event) => {\n        resolve(event.detail);\n    });\n    return promise;\n};\nconst onceEvent = (element, eventName, callback) => {\n    const handler = (ev) => {\n        removeEventListener(element, eventName, handler);\n        callback(ev);\n    };\n    addEventListener(element, eventName, handler);\n};\nconst isCancel = (role) => {\n    return role === 'cancel' || role === BACKDROP;\n};\nconst defaultGate = (h) => h();\n/**\n * Calls a developer provided method while avoiding\n * Angular Zones. Since the handler is provided by\n * the developer, we should throw any errors\n * received so that developer-provided bug\n * tracking software can log it.\n */\nconst safeCall = (handler, arg) => {\n    if (typeof handler === 'function') {\n        const jmp = config.get('_zoneGate', defaultGate);\n        return jmp(() => {\n            try {\n                return handler(arg);\n            }\n            catch (e) {\n                throw e;\n            }\n        });\n    }\n    return undefined;\n};\nconst BACKDROP = 'backdrop';\nconst GESTURE = 'gesture';\nconst OVERLAY_GESTURE_PRIORITY = 39;\n/**\n * Creates a delegate controller.\n *\n * Requires that the component has the following properties:\n * - `el: HTMLElement`\n * - `hasController: boolean`\n * - `delegate?: FrameworkDelegate`\n *\n * @param ref The component class instance.\n */\nconst createDelegateController = (ref) => {\n    let inline = false;\n    let workingDelegate;\n    const coreDelegate = CoreDelegate();\n    /**\n     * Determines whether or not an overlay is being used\n     * inline or via a controller/JS and returns the correct delegate.\n     * By default, subsequent calls to getDelegate will use\n     * a cached version of the delegate.\n     * This is useful for calling dismiss after present,\n     * so that the correct delegate is given.\n     * @param force `true` to force the non-cached version of the delegate.\n     * @returns The delegate to use and whether or not the overlay is inline.\n     */\n    const getDelegate = (force = false) => {\n        if (workingDelegate && !force) {\n            return {\n                delegate: workingDelegate,\n                inline,\n            };\n        }\n        const { el, hasController, delegate } = ref;\n        /**\n         * If using overlay inline\n         * we potentially need to use the coreDelegate\n         * so that this works in vanilla JS apps.\n         * If a developer has presented this component\n         * via a controller, then we can assume\n         * the component is already in the\n         * correct place.\n         */\n        const parentEl = el.parentNode;\n        inline = parentEl !== null && !hasController;\n        workingDelegate = inline ? delegate || coreDelegate : delegate;\n        return { inline, delegate: workingDelegate };\n    };\n    /**\n     * Attaches a component in the DOM. Teleports the component\n     * to the root of the app.\n     * @param component The component to optionally construct and append to the element.\n     */\n    const attachViewToDom = async (component) => {\n        const { delegate } = getDelegate(true);\n        if (delegate) {\n            return await delegate.attachViewToDom(ref.el, component);\n        }\n        const { hasController } = ref;\n        if (hasController && component !== undefined) {\n            throw new Error('framework delegate is missing');\n        }\n        return null;\n    };\n    /**\n     * Moves a component back to its original location in the DOM.\n     */\n    const removeViewFromDom = () => {\n        const { delegate } = getDelegate();\n        if (delegate && ref.el !== undefined) {\n            delegate.removeViewFromDom(ref.el.parentElement, ref.el);\n        }\n    };\n    return {\n        attachViewToDom,\n        removeViewFromDom,\n    };\n};\n/**\n * Constructs a trigger interaction for an overlay.\n * Presents an overlay when the trigger is clicked.\n *\n * Usage:\n * ```ts\n * triggerController = createTriggerController();\n * triggerController.addClickListener(el, trigger);\n * ```\n */\nconst createTriggerController = () => {\n    let destroyTriggerInteraction;\n    /**\n     * Removes the click listener from the trigger element.\n     */\n    const removeClickListener = () => {\n        if (destroyTriggerInteraction) {\n            destroyTriggerInteraction();\n            destroyTriggerInteraction = undefined;\n        }\n    };\n    /**\n     * Adds a click listener to the trigger element.\n     * Presents the overlay when the trigger is clicked.\n     * @param el The overlay element.\n     * @param trigger The ID of the element to add a click listener to.\n     */\n    const addClickListener = (el, trigger) => {\n        removeClickListener();\n        const triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;\n        if (!triggerEl) {\n            printIonWarning(`A trigger element with the ID \"${trigger}\" was not found in the DOM. The trigger element must be in the DOM when the \"trigger\" property is set on an overlay component.`, el);\n            return;\n        }\n        const configureTriggerInteraction = (targetEl, overlayEl) => {\n            const openOverlay = () => {\n                overlayEl.present();\n            };\n            targetEl.addEventListener('click', openOverlay);\n            return () => {\n                targetEl.removeEventListener('click', openOverlay);\n            };\n        };\n        destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el);\n    };\n    return {\n        addClickListener,\n        removeClickListener,\n    };\n};\n\nexport { BACKDROP as B, GESTURE as G, OVERLAY_GESTURE_PRIORITY as O, alertController as a, actionSheetController as b, popoverController as c, createDelegateController as d, createTriggerController as e, present as f, dismiss as g, eventMethod as h, isCancel as i, prepareOverlay as j, setOverlayId as k, loadingController as l, modalController as m, focusFirstDescendant as n, getPresentedOverlay as o, pickerController as p, activeAnimations as q, safeCall as s, toastController as t };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}